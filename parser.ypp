%{
	#include <iostream>
	#include <stdlib.h>
	#include "source.hpp"
	#include "hw3_output.hpp"
	#include "scope.h"

	using namespace output;

  int yylex();
  extern int yylineno;
  extern char* yytext;
  extern void discoveringYYSTYPE(int yy);
  TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs);
  void typeCheck(TypeContainer* lhs,TypeContainer* rhs);
  void isBool(TypeContainer* con);
  void wasDefined(TypeContainer* con);
  void notDefined(TypeContainer* con);
  void CheckDefinedFunc(TypeContainer* con);
  void insertToSymbolTable(TypeContainer* type,TypeContainer* id);
  string getActualType(TypeContainer* some_data);
  int yyerror(const char * message);
  string getRetType(ScopeData some_func);
  void numCheck(TypeContainer* data);
  string getFunctionParametersString(string id);
  vector<string> parseFuncParams(string id);
  string StringFromVec(vector<string> params);
  vector<string> functionTypeToVector(string function_type);
  string getFunctionFullType(string id);
  vector<string> getFunctionParameters(string id);
  void enumtTypeCheck(TypeContainer* enumtype,TypeContainer* exp);
  vector<ScopeData> createFuncArgsVec(TypeContainer* formals);
  Scope table;
  int while_count = 0;
  string last_function_ret_type = "VOID";
  bool is_main_defined = false;

%}

%token BOOL
%token VOID INT BYTE B ENUM TRUE FALSE RETURN WHILE IF
%token BREAK CONTINUE SC COMMA LPAREN RPAREN LBRACE RBRACE
%token  ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left RELEQ
%nonassoc RELOP
%left BINOPL
%left BINOPH
%right CAST
%right NOT
%nonassoc THEN
%nonassoc ELSE


%%
Program	: {
	table.insertScope();
	vector<string> print_func_args;
	vector<string> printi_func_args;
	print_func_args.push_back("STRING");
	printi_func_args.push_back("INT");
	string print_func_type = makeFunctionType("VOID",print_func_args);
	string printi_func_type = makeFunctionType("VOID",printi_func_args);
	table.addFuncData(ScopeData("print",0,print_func_type));
	table.addFuncData(ScopeData("printi",0,printi_func_type));
  }
	Enums Funcs {
        if (!is_main_defined){
            errorMainMissing();
            exit(0);
        }
        ScopeData main_data = table.getDataCopy("main");
        if (main_data.getTypeCopy()!="()->VOID"){
            errorMainMissing();
            exit(0);
        }
    }				{};
Funcs : /*epsilon*/ 																									{};
Funcs : FuncDecl Funcs 																								{};
FuncDecl : RetType {last_function_ret_type=$1->getType();} ID {
    wasDefined($3);
    if ($3->getName()=="main"){
        is_main_defined=true;
    }
    } LPAREN Formals RPAREN LBRACE {
        table.insertScope();
        vector<ScopeData> created_args = createFuncArgsVec($6);
        table.insertFuncArgs(created_args);
    } Statements RBRACE  {
    vector<string> formals_types = $6->getTypes();
    string func_type = makeFunctionType($1->getType(),formals_types);
    endScope();
    table.printLastScopeData();
    table.removeScope();
    table.addFuncData(ScopeData($3->getName(),0,func_type));
};
Enums : /*epsilon*/																		{};
Enums : EnumDecl Enums																{};
EnumDecl : ENUM ID {
	wasDefined($2);
} LBRACE EnumeratorList RBRACE SC   {
    vector<string> enum_names = ((FormalListClass*)$5)->getNames();
    table.addScopeData(ScopeData($2->getName(),0,"ENUM",enum_names));
};
RetType : Type																				{$$=$1;};
RetType : VOID																				{$$=$1;};
Formals : /*epsilon*/																	{$$ = new FormalListClass();};
Formals : FormalsList																	{$$=$1;};
FormalsList : FormalDecl															{$$=$1;};
FormalsList : FormalDecl COMMA FormalsList						{((FormalListClass*)$1)->addIds(((FormalListClass*)$3)->getIds());$$=$1;};
FormalDecl : Type ID																	{$$=new FormalListClass(Id($2->getName(),$1->getType()));};
FormalDecl : EnumType ID															{$$=$1;};
EnumeratorList : Enumerator														{$$=new FormalListClass(Id($1->getName(),$1->getType()));};
EnumeratorList : EnumeratorList COMMA Enumerator	{
    ((FormalListClass*)$3)->addIds(((FormalListClass*)$1)->getIds());
    $$=$3;
};
Enumerator : ID	{
	wasDefined($1);
	$$=new FormalListClass(Id($1->getName(),$1->getType()));
};
Statements : Statement																{};
Statements : Statements Statement											{};
Statement : LBRACE {table.insertScope();} Statements RBRACE {
    endScope();
    table.printLastScopeData();
    table.removeScope();
};
Statement : Type ID {
    wasDefined($2);
    insertToSymbolTable($1,$2);
    } SC {
};
Statement : EnumType ID {
    notDefined($1);
	wasDefined($2);
    table.addScopeData(ScopeData($2->getName(),table.getNextOffset(),"enum "+$1->getName()));} 
    SC	{};
Statement : EnumDecl															{};
Statement : Type ID {
	wasDefined($2);
	insertToSymbolTable($1,$2);
} ASSIGN Exp SC	{
	typeCheck($1,$5);
	};
Statement : EnumType ID {wasDefined($2);} ASSIGN Exp {  
    enumtTypeCheck($1,$5);
    table.addScopeData(ScopeData($2->getName(),table.getNextOffset(),"enum "+$1->getName()));
    } SC {
};
Statement : ID { notDefined($1);} ASSIGN Exp SC {typeCheck($1,$4);};
Statement : Call SC																		{};
Statement : RETURN SC 	{
    if (last_function_ret_type!="VOID"){
        errorMismatch(yylineno);
    }
};
Statement : RETURN Exp {
    if (getActualType($2) != last_function_ret_type){
        errorMismatch(yylineno);
    }
} SC	
Statement : IF LPAREN CheckType RPAREN InsertScope
    Statement %prec THEN RemoveScope
Statement : IF LPAREN CheckType RPAREN InsertScope Statement RemoveScope ELSE InsertScope Statement RemoveScope
Statement : WHILE LPAREN CheckType RPAREN {
    while_count++;
    table.insertScope();
    } Statement {
        while_count--;
        table.printLastScopeData();
        table.removeScope();
};
InsertScope : {table.insertScope();}
RemoveScope : {table.removeScope();}
CheckType : Exp {isBool($1);};
Statement : BREAK SC  {
    if (while_count==0){
        errorUnexpectedBreak(yylineno);
    }
};
Statement : CONTINUE SC	{
    if(while_count==0){
        errorUnexpectedContinue(yylineno);
    }
};
Call : CheckFunc LPAREN ExpList RPAREN  {
	string func_params_string = getFunctionParametersString($1->getName()); // (type1,type2,type3..)
  vector<string> func_def_params = parseFuncParams(func_params_string);
  vector<string> explist_params = $3->getTypes(); // returns the typelist
  if(func_def_params.size() != explist_params.size()){
    vector<string> func_params = parseFuncParams(func_params_string);
    errorPrototypeMismatch(yylineno, $1->getName(), func_params);
    exit(0);
  }
  else {
    for(int i = 0; i < func_def_params.size(); ++i){
      if(func_def_params[i] == explist_params[i] ||
        (func_def_params[i] == "INT" && explist_params[i] == "BYTE")){
          /* all good do nothing */
      }
      else {
        vector<string> func_params = parseFuncParams(func_params_string);
        errorPrototypeMismatch(yylineno, $1->getName(), func_params);
        exit(0);
      }
    }
  }
};
Call : CheckFunc LPAREN RPAREN {
  string func_params_string = getFunctionParametersString($1->getName());
	if( func_params_string != "()"){
    vector<string> func_params = parseFuncParams(func_params_string);
    errorPrototypeMismatch(yylineno, $1->getName(), func_params);
	}
};
CheckFunc : ID {
    CheckDefinedFunc($1);
};
ExpList : Exp																					{$$=new ExpList($1->getType());};
ExpList : Exp COMMA ExpList														{$$=new ExpList($1->getType());$$->addTypes($3->getTypes());};
Type : INT																						{$$=$1;};
Type : BYTE																						{$$=$1;};
Type : BOOL																						{$$=$1;};
EnumType : ENUM ID																		{$$=new Enum($2->getName(),"ENUM");};
Exp : LPAREN Exp RPAREN																{$$=$2;};
Exp : Exp BINOPH Exp {
	numCheck($1);
  numCheck($2);
	$$ = binOpType($1,$3);
};
Exp : Exp BINOPL Exp {
	numCheck($1);
  numCheck($3);
	$$ = binOpType($1,$3);
};
Exp : ID																							{$$=$1;};
Exp : Call																						{$$=$1;};
Exp : NUM																							{$$=$1;};
Exp : NUM B		{
    if ($1->getVal()>255){
        errorByteTooLarge(yylineno,std::to_string($1->getVal()));
    }
    $$=new Byte($1->getVal(),"BYTE");
};
Exp : STRING																					{$$=$1;};
Exp : TRUE																						{$$=$1;};
Exp : FALSE																						{$$=$1;};
Exp : NOT Exp {
    isBool($2);
    $$=new Bool(!(((Bool*)$2)->getValue()),"BOOL");
};
Exp : Exp AND Exp {
	isBool($1);
	isBool($3);
	$$=new Bool($1->getValue() && $3->getValue(),"BOOL");
};
Exp : Exp OR Exp {
	isBool($1);
	isBool($3);
	$$=new Bool($1->getValue() || $3->getValue(),"BOOL");
};
Exp : Exp RELOP Exp  {
  numCheck($1);
  numCheck($3);
	typeCheck($1,$3);
	$$=new Bool(true,"BOOL");
};
Exp : Exp RELEQ Exp{
  numCheck($1);
  numCheck($3);
	typeCheck($1,$3);
	$$=new Bool(false,"BOOL");
};
Exp : LPAREN Type {
    if($2->getType()!="INT"){
        errorMismatch(yylineno);
        exit(0);
    } } RPAREN Exp %prec CAST {
        if (getActualType($5)!="ENUM"){
            errorMismatch(yylineno);
            exit(0);
        }
        $$=$2;
};

%%

int main()
{
	yyparse();
  endScope();
	table.printLastScopeData();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}


TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs) {
  string type_one = lhs->getType();
  string type_two = rhs->getType();
  if (type_one == "INT" || type_two == "INT"){
	  return new Int(lhs->getVal()+rhs->getVal(),"INT");
  }
  return new Int(lhs->getVal() + rhs->getVal(), "BYTE");
}

void typeCheck(TypeContainer* lhs,TypeContainer* rhs){
    string lhs_type = getActualType(lhs);
    string rhs_type = getActualType(rhs);
    if(lhs_type == "INT" && rhs_type =="BYTE") return;
    if(lhs_type != rhs_type){
      errorMismatch(yylineno);
      exit(0);
	}
}

void isBool(TypeContainer* con){
    string type = getActualType(con);
		if (type != "BOOL"){
			errorMismatch(yylineno);
			exit(0);
		}
 }

void wasDefined(TypeContainer* con){
	if( table.exist( con->getName() )){
		errorDef(yylineno, con->getName());
		exit(0);
	}
}

void notDefined(TypeContainer* con){
	 if(!table.exist( con->getName() )){
		errorUndef(yylineno, con->getName());
		exit(0);
	}
}

void CheckDefinedFunc(TypeContainer* con){
	 string arrow = "->";
     bool id_exists = table.exist(con->getName());
     if (!id_exists){
         errorUndefFunc(yylineno,con->getName());
         exit(0);
     }
     ScopeData copy = table.getDataCopy(con->getName());
     string type = copy.getTypeCopy();
     if (type.find(arrow)==std::string::npos){
         errorUndefFunc(yylineno,con->getName());
         exit(0);
     }
}


void insertToSymbolTable(TypeContainer* type,TypeContainer* id){
	ScopeData inserted_element = ScopeData(id->getName(),table.getNextOffset(),type->getType());
	table.addScopeData(inserted_element);
}

/* this function returns the "returned type" of a function */
string getActualType(TypeContainer* some_data){
    string type = some_data->getType();
    if (type=="ID"){
        type = table.getDataCopy(some_data->getName()).getTypeCopy();
        std::size_t location = type.find("->");
        if (location == std::string::npos){
            return type;
        }
        type = type.substr(location+2);
    }
    return type;
}

void numCheck(TypeContainer* data){
    string type = getActualType(data);
    if (type!="INT" && type!="BYTE"){
        errorMismatch(yylineno);
        exit(0);
    }
}

string getRetType(ScopeData some_func){
    string type = some_func.getTypeCopy();
    std::size_t location = type.find("->");
    type = type.substr(location+2);
    return type;
}

/* gets function name and returns the type (type1,type2,type3) */
string getFunctionParametersString(string id){
  vector<string> params;
  ScopeData func_data = table.getDataCopy(id);
  string type = func_data.getTypeCopy();
  std::size_t location = type.find("->");
  type = type.substr(0,location);
  return type;
}


vector<string> functionTypeToVector(string function_type) {
  function_type = function_type.substr(0, function_type.find("->"));
  function_type = function_type.substr(1, function_type.length() - 1);
  std::string s = function_type;
  std::string delimiter = ",";
  vector<string> output_vector;
  size_t pos = 0;
  std::string token;
  while ((pos = s.find(delimiter)) != std::string::npos) {
    token = s.substr(0, pos);
    output_vector.push_back(token);
    s.erase(0, pos + delimiter.length());
  }
  return output_vector;
}

string getFunctionFullType(string id){
    return table.getDataCopy(id).getTypeCopy();
}

vector<string> getFunctionParameters(string id){
    string type = getFunctionFullType(id);
    return functionTypeToVector(type);
}

void enumtTypeCheck(TypeContainer* enumtype,TypeContainer* exp){
    string checked_enum = enumtype->getName();
    string exp_type = getActualType(exp);
    std::size_t location = exp_type.find(" ");
    if (location==std::string::npos){
        errorMismatch(yylineno);
        exit(0);
    }
    string actual_enum_id = exp_type.substr(location+1);
    if (actual_enum_id!=checked_enum){
        errorMismatch(yylineno);
        exit(0);
    }
}


vector<ScopeData> createFuncArgsVec(TypeContainer* formals){
    vector<Id> id_vec = ((FormalListClass*)formals)->getIds();
    vector<ScopeData> output_vec;
    int i=-1;
    for (Id id : id_vec){
        output_vec.push_back(ScopeData(id.getName(),i,id.getType()));
        i--;
    }
    return output_vec;
}

vector<string> parseFuncParams(string type){
  vector<string> params;
  string param_string = type.substr(1,type.size()-2);
  int param_num = (int)std::count(param_string.begin(), param_string.end(), ',');
  int pos = 0;
  for(int i = 0; i < param_num; i++){
    pos = (int)type.find(",");
    params.push_back(param_string.substr(0,pos-1));
    param_string = param_string.substr(pos);
  }
  params.push_back(param_string);
  //for(auto st : params){
  //  std::cout << st << "  " << std::endl;
  //}
  return params;
}

string StringFromVec(vector<string> params){
  if(params.size() == 0) return "()";
  string temp = "(";
  for(string param : params){
    temp += param + ',';
  }
  return temp.substr(0,temp.size()-1)+')';
}
