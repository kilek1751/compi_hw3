%{
	#include <iostream>
	#include <stdlib.h>
	#include "source.hpp"
	#include "hw3_output.hpp"
	#include "scope.h"

	using namespace output;

	int yylex();
	extern int yylineno;
	extern char* yytext;
	extern void discoveringYYSTYPE(int yy);
	TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs);
	void typeCheck(TypeContainer* lhs,TypeContainer* rhs);
	void isBool(TypeContainer* con);
	void wasDefined(TypeContainer* con);
	void notDefined(TypeContainer* con);
	void CheckDefinedFunc(TypeContainer* con);
	void insertToSymbolTable(TypeContainer* type,TypeContainer* id);
    string getActualType(TypeContainer* some_data);
	int yyerror(const char * message);
    string getRetType(ScopeData some_func);
    void numCheck(TypeContainer* data);
	Scope table;
    int while_count = 0;
    string last_function_ret_type = "VOID";
    bool is_main_defined = false;

%}

%token BOOL
%token VOID INT BYTE B ENUM TRUE FALSE RETURN WHILE IF
%token BREAK CONTINUE SC COMMA LPAREN RPAREN LBRACE RBRACE
%token  ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left RELEQ
%nonassoc RELOP
%left BINOPL
%left BINOPH
%right CAST
%right NOT
%nonassoc THEN
%nonassoc ELSE


%%

Program	: {
	table.insertScope();
	vector<string> print_func_args;
	vector<string> printi_func_args;
	print_func_args.push_back("STRING");
	printi_func_args.push_back("INT");
	string print_func_type = makeFunctionType("VOID",print_func_args);
	string printi_func_type = makeFunctionType("VOID",printi_func_args);
	table.addFuncData(ScopeData("print",0,print_func_type));
	table.addFuncData(ScopeData("printi",0,printi_func_type));
}
	Enums Funcs {
        if (!is_main_defined){
            errorMainMissing();
            exit(0);
        }
        ScopeData main_data = table.getDataCopy("main");
        if (main_data.getTypeCopy()!="()->VOID"){
            errorMainMissing();
            exit(0);
        }
    }																								{};
Funcs : /*epsilon*/ 																									{};
Funcs : FuncDecl Funcs 																								{};
FuncDecl : RetType {last_function_ret_type=$1->getType();} ID {
    wasDefined($3);
    if ($3->getName()=="main"){
        is_main_defined=true;
    }
    } LPAREN Formals RPAREN LBRACE {table.insertScope();} Statements RBRACE  {
 	vector<string> formals_types = $6->getTypes();
	string func_type = makeFunctionType($1->getType(),formals_types);
	endScope();
	table.printLastScopeData();
    table.removeScope();
    table.addFuncData(ScopeData($3->getName(),0,func_type));
};
Enums : /*epsilon*/																		{};
Enums : EnumDecl Enums																{};
EnumDecl : ENUM ID {
	wasDefined($2);
} LBRACE EnumeratorList RBRACE SC   {
    vector<string> enum_names = ((FormalListClass*)$5)->getNames();
    table.addScopeData(ScopeData($2->getName(),0,"ENUM",enum_names));
};
RetType : Type																				{$$=$1;};
RetType : VOID																				{$$=$1;};
Formals : /*epsilon*/																	{$$ = new FormalListClass();};
Formals : FormalsList																	{$$=$1;};
FormalsList : FormalDecl															{$$=$1;};
FormalsList : FormalDecl COMMA FormalsList						{((FormalListClass*)$1)->addIds(((FormalListClass*)$3)->getIds());$$=$1;};
FormalDecl : Type ID																	{$$=new FormalListClass(Id($2->getName(),$1->getType()));};
FormalDecl : EnumType ID															{$$=$1;};
EnumeratorList : Enumerator														{$$=new FormalListClass(Id($1->getName(),$1->getType()));};
EnumeratorList : EnumeratorList COMMA Enumerator	{
    ((FormalListClass*)$3)->addIds(((FormalListClass*)$1)->getIds());
    $$=$3;
};
Enumerator : ID	{
	wasDefined($1);
	$$=new FormalListClass(Id($1->getName(),$1->getType()));
};
Statements : Statement																{};
Statements : Statements Statement											{};
Statement : LBRACE {table.insertScope();} Statements RBRACE {
    endScope();
    table.printLastScopeData();
    table.removeScope();
};
Statement : Type ID {
    wasDefined($2);
    insertToSymbolTable($1,$2);
    } SC {
};
Statement : EnumType ID {
    notDefined($1);
	wasDefined($2);
} SC														{};
Statement : EnumDecl															{};
Statement : Type ID {
	wasDefined($2);
	insertToSymbolTable($1,$2);
	} ASSIGN Exp SC	{
	typeCheck($1,$5);
	};
Statement : EnumType ID {wasDefined($2);} ASSIGN Exp {  
    typeCheck($2,$5);
    } SC {
};
Statement : ID { notDefined($1);} ASSIGN Exp SC {typeCheck($1,$4);};
Statement : Call SC																		{};
Statement : RETURN SC 	{
    if (last_function_ret_type!="VOID"){
        errorMismatch(yylineno);
    }
};
Statement : RETURN Exp {
    if (getActualType($2)!=last_function_ret_type){
        errorMismatch(yylineno);
    }
} SC	
Statement : IF LPAREN CheckType RPAREN InsertScope
    Statement %prec THEN RemoveScope
Statement : IF LPAREN CheckType RPAREN InsertScope Statement RemoveScope ELSE InsertScope Statement RemoveScope
Statement : WHILE LPAREN CheckType RPAREN {
    while_count++;
    table.insertScope();
    } Statement {
        while_count--;
        table.printLastScopeData();
        table.removeScope();
};
InsertScope : {table.insertScope();}
RemoveScope : {table.removeScope();}
CheckType : Exp {isBool($1);};
Statement : BREAK SC  {
    if (while_count==0){
        errorUnexpectedBreak(yylineno);
    }
};
Statement : CONTINUE SC	{
    if(while_count==0){
        errorUnexpectedContinue(yylineno);
    }
};
Call : CheckFunc LPAREN ExpList RPAREN {
	/*
	string& func = $1->getType();
	int pos = func.find_first_of("->");
	string prototypes = func.substr(0,pos);
	string temp = makeFunctionType("void", $4->getTypes());
	pos = temp.find_first_of("->");
	string prototypes_two = temp.substr(0,pos);
	if(prototypes != prototypes_two){
		errorPrototypeMismatch(yylineno, $1->getName(), $1->getTypes());
	} */
};
Call : CheckFunc LPAREN RPAREN {/*
	if($1->getTypes().size() != 0){
		errorPrototypeMismatch(yylineno, $1->getName(), $1->getTypes());
	} */
};
CheckFunc : ID {
    CheckDefinedFunc($1);
};
ExpList : Exp																					{$$=new ExpList($1->getType());};
ExpList : Exp COMMA ExpList														{$$=new ExpList($1->getType());$$->addTypes($3->getTypes());};
Type : INT																						{$$=$1;};
Type : BYTE																						{$$=$1;};
Type : BOOL																						{$$=$1;};
EnumType : ENUM ID																		{$$=new Enum($2->getName(),"ENUM");};
Exp : LPAREN Exp RPAREN																{$$=$2;};
Exp : Exp BINOPH Exp {
	numCheck($1);
    numCheck($2);
	$$ = binOpType($1,$3);
};
Exp : Exp BINOPL Exp {
	numCheck($1);
    numCheck($3);
	$$ = binOpType($1,$3);
};
Exp : ID																							{$$=$1;};
Exp : Call																						{$$=$1;};
Exp : NUM																							{$$=$1;};
Exp : NUM B		{
    if ($1->getVal()>255){
        errorByteTooLarge(yylineno,std::to_string($1->getVal()));
    }
    $$=new Byte($1->getVal(),"BYTE");
};
Exp : STRING																					{$$=$1;};
Exp : TRUE																						{$$=$1;};
Exp : FALSE																						{$$=$1;};
Exp : NOT Exp {
    isBool($2);
    $$=new Bool(!(((Bool*)$2)->getValue()),"BOOL");
};
Exp : Exp AND Exp {
	isBool($1);
	isBool($3);
	$$=new Bool($1->getValue() && $3->getValue(),"BOOL");
};
Exp : Exp OR Exp {
	isBool($1);
	isBool($3);
	$$=new Bool($1->getValue() || $3->getValue(),"BOOL");
};
Exp : Exp RELOP Exp  {
    numCheck($1);
    numCheck($3);
	typeCheck($1,$3);
	$$=new Bool(yytext,"BOOL");
};
Exp : Exp RELEQ Exp{
    numCheck($1);
    numCheck($3);
	typeCheck($1,$3);
	$$=new Bool(yytext,"BOOL");
};
Exp : LPAREN Type {
    if($2->getType()!="INT"){
        errorMismatch(yylineno);
        exit(0);
    } } RPAREN Exp %prec CAST {
        if (getActualType($5)!="ENUM"){
            errorMismatch(yylineno);
            exit(0);
        }
        $$=$2;
};

%%

int main()
{
	yyparse();
    endScope();
	table.printLastScopeData();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}


TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs) {
  string type_one = lhs->getType();
  string type_two = rhs->getType();
  if (type_one == "INT" || type_two == "INT"){
	  return new Int(lhs->getVal()+rhs->getVal(),"INT");
  }
  return new Int(lhs->getVal() + rhs->getVal(), "BYTE");
}

void typeCheck(TypeContainer* lhs,TypeContainer* rhs){
    string lhs_type = getActualType(lhs);
    string rhs_type = getActualType(rhs);
    
	 if(lhs_type != rhs_type){
		errorMismatch(yylineno);
		exit(0);
	}
}

void isBool(TypeContainer* con){
    string type = getActualType(con);
		if (type == "BOOL"){
			errorMismatch(yylineno);
			exit(0);
		}
 }

void wasDefined(TypeContainer* con){
	if( table.exist( con->getName() )){
		errorDef(yylineno, con->getName());
		exit(0);
	}
}

void notDefined(TypeContainer* con){
	 if(!table.exist( con->getName() )){
		errorUndef(yylineno, con->getName());
		exit(0);
	}
}

void CheckDefinedFunc(TypeContainer* con){
	 string arrow = "->";
     bool id_exists = table.exist(con->getName());
     if (!id_exists){
         errorUndefFunc(yylineno,con->getName());
         exit(0);
     }
     ScopeData copy = table.getDataCopy(con->getName());
     string type = copy.getTypeCopy();
     if (type.find(arrow)==std::string::npos){
         errorUndefFunc(yylineno,con->getName());
         exit(0);
     }
}


void insertToSymbolTable(TypeContainer* type,TypeContainer* id){
	ScopeData inserted_element = ScopeData(id->getName(),table.getNextOffset(),type->getType());
	table.addScopeData(inserted_element);
}

/* this function returns the "returned type" of a function */
string getActualType(TypeContainer* some_data){
    string type = some_data->getType();
    if (type=="ID"){
        type = table.getDataCopy(some_data->getName()).getTypeCopy();
        std::size_t location = type.find("->");
        if (location == std::string::npos){
            return type;
        }
        type = type.substr(location+2);
    }
    return type;
}

void numCheck(TypeContainer* data){
    string type = getActualType(data);
    if (type!="INT" || type!="BYTE"){
        errorMismatch(yylineno);
        exit(0);
    }
}

string getRetType(ScopeData some_func){
    string type = some_func.getTypeCopy();
    std::size_t location = type.find("->");
    type = type.substr(location+2);
    return type;
}

string getFunctionParameters(string id){
    ScopeData func_data = table.getDataCopy(id);
    string type = func_data.getTypeCopy();
    std::size_t location = type.find("->");
    type = type.substr(0,location);
    return type;

}
