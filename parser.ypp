%{
	#include <iostream>
	#include <stdlib.h>
	#include "source.hpp"
	#include "hw3_output.hpp"
	#include "scope.h"

	using namespace output;

	int yylex();
	extern int yylineno;
	extern char* yytext;
	extern void discoveringYYSTYPE(int yy);
	TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs);
	void typeCheck(TypeContainer* lhs,TypeContainer* rhs);
	int yyerror(const char * message);
	Scope table;

%}

%token LEXERROR BOOL
%token VOID INT BYTE B ENUM TRUE FALSE RETURN WHILE IF
%token BREAK CONTINUE SC COMMA LPAREN RPAREN LBRACE RBRACE
%token  ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left RELEQ
%nonassoc RELOP
%left BINOPL
%left BINOPH
%right CAST
%right NOT
%left PARANS
%nonassoc THEN
%nonassoc ELSE


%%

Program	: {
	table.insertScope();
	vector<string> print_func_args;
	vector<string> printi_func_args;
	print_func_args.push_back("string");
	printi_func_args.push_back("int");
	string print_func_type = makeFunctionType("void",print_func_args);
	string printi_func_type = makeFunctionType("void",printi_func_args);
	table.addScopeData(ScopeData("print",0,print_func_type));
	table.addScopeData(ScopeData("printi",0,printi_func_type));
	endScope();
	table.printLastScopeData();
}
	Enums Funcs 																								{};
Funcs : /*epsilon*/ 																									{};
Funcs : FuncDecl Funcs 																								{};
FuncDecl : RetType ID {/*idcheck*/} LPAREN Formals RPAREN LBRACE {/*startscope*/} Statements RBRACE {/*endscope*/} { 
 	vector<string> formals_types = $5->getTypes();	
	string func_type = makeFunctionType($1->getType(),formals_types);
	table.addScopeData(ScopeData($2->getName(),0,func_type));
	endScope();
	table.printLastScopeData();
};
Enums : /*epsilon*/																		{};
Enums : EnumDecl Enums																{};
EnumDecl : ENUM ID LBRACE EnumeratorList RBRACE SC		{};
RetType : Type																				{$$=$1;};
RetType : VOID																				{$$=$1;};
Formals : /*epsilon*/																	{$$ = new FormalListClass();};
Formals : FormalsList																	{$$=$1;};
FormalsList : FormalDecl															{$$=$1;};
FormalsList : FormalDecl COMMA FormalsList						{((FormalListClass*)$1)->addIds(((FormalListClass*)$3)->getIds());$$=$1;};
FormalDecl : Type ID																	{$$=new FormalListClass(Id($2->getName(),$1->getType()));};
FormalDecl : EnumType ID															{$$=new FormalListClass(Id($2->getName(),$1->getType()));};
EnumeratorList : Enumerator														{};
EnumeratorList : EnumeratorList COMMA Enumerator			{};
Enumerator : ID																				{};
Statements : Statement																{};
Statements : Statements Statement											{};
Statement : LBRACE Statements RBRACE									{};
Statement : Type ID {wasDefined($2);} SC {

};
Statement : EnumType ID SC														{};
Statement : EnumDecl																	{};
Statement : Type ID {wasDefined($2);} ASSIGN Exp SC	{
	typeCheck($1,$5);
	};
Statement : EnumType ID {wasDefined($2);} ASSIGN Exp SC {

};
Statement : ID {wasDefined($2);} ASSIGN Exp SC 	{
	typeCheck($1,$4);
};
Statement : Call SC																		{};
Statement : RETURN SC																	{};
Statement : RETURN Exp SC															{};
Statement : IF LPAREN Exp {isBool($3);} RPAREN Statement %prec THEN	{};
Statement : IF LPAREN Exp {isBool($3);} RPAREN Statement ELSE Statement {};
Statement : WHILE LPAREN Exp {isBool($3);} RPAREN Statement {};
Statement : BREAK SC																	{};
Statement : CONTINUE SC																{};
Call : ID {CheckDefinedFunc($1)} LPAREN ExpList RPAREN {
	string& func = $1->getType();
	int pos = func.find_first_of("->");
	string prototypes = func.substr(0,pos);
	string temp = makeFunctionType("void", $4->getTypes());
	pos = temp.find_first_of("->");
	string prototypes_two = temp.substr(0,pos);
	if(prototypes != prototypes_two){
		errorPrototypeMismatch(yylineno, $1->getName(), $1->getTypes());						#TODO getTypes returns a vector, should it ?
	}
};
Call : ID {CheckDefinedFunc($1)} LPAREN RPAREN {
	if($1->getTypes().size() != 0){
		errorPrototypeMismatch(yylineno, $1->getName(), $1->getTypes())							#TODO getTypes returns a vector, should it ?
	}
};
ExpList : Exp																					{$$=new ExpList($1->getType());};
ExpList : Exp COMMA ExpList														{$$=new ExpList($1->getType());$$->addTypes($3->getTypes());};
Type : INT																						{$$=$1;};
Type : BYTE																						{$$=$1;};
Type : BOOL																						{$$=$1;};
EnumType : ENUM ID																		{$$=new Enum($2->getName(),"ENUM");};
Exp : LPAREN Exp RPAREN																{$$=$2;};
Exp : Exp BINOPH Exp {
	typeCheck($1,$3);
	$$ = binOpType($1,$3);
};
Exp : Exp BINOPL Exp {
	typeCheck($1,$3);
	$$ = binOpType($1,$3);
};
Exp : ID																							{$$=new Id(yytext,"ID");};
Exp : Call																						{$$=$1;};
Exp : NUM																							{$$=new Int(yytext,"INT");};
Exp : NUM B																						{$$=new Byte($1->getVal(),"BYTE");};
Exp : STRING																					{$$=new String(yytext,"STRING");};
Exp : TRUE																						{$$=new Bool(true,"BOOL");};
Exp : FALSE																						{$$=new Bool(false,"BOOL");};
Exp : NOT Exp																					{$$=new Bool(yytext,"BOOL");}; # should be yytext -> $2->type
Exp : Exp AND Exp {
	isBool($1);
	isBool($2);
	$$=new Bool(yytext,"BOOL");};
Exp : Exp OR Exp {
	isBool($1);
	isBool($2);
	$$=new Bool(yytext,"BOOL");
};
Exp : Exp RELOP Exp {
	typeCheck($1,$3);
	$$=new Bool(yytext,"BOOL");
};
Exp : Exp RELEQ Exp {
	typeCheck($1,$3);
	$$=new Bool(yytext,"BOOL");
};
Exp : LPAREN Type RPAREN Exp %prec CAST								{$$=$2;};

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}


TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs) {
  string type_one = lhs->getType();
  string type_two = rhs->getType();
  if (type_one == "INT" || type_two == "INT"){
	  return new Int(lhs->getVal()+rhs->getVal(),"INT");
  }
  return new Int(lhs->getVal() + rhs->getVal(), "BYTE");
}

 void typeCheck(TypeContainer* lhs,TypeContainer* rhs){
	 if(lhs->getType() != rhs->getType()){
		 errorMismatch(yylineno);
	 }
 }

 void isBool(TypeContainer* con){
		if (con->getType() == "BOOL"){
			errorMismatch(yylineno);
		}
 }

 void wasDefined(TypeContainer* con){
	 if( Scope::exist( con->getName() ){
		 errorDef(yylineno, con->getName());
	 }
 }

 void notDefined(TypeContainer* con){
	 if(Scope::exist( !con->getName() )){
		 errorUndef(yylineno, con->getName());
	 }
 }

 void CheckDefinedFunc(TypeContainer* con){
	 string arrow = "->";
	 if( !Scope::exist( con->getName()) ||
	 			con->getType().find(arrow) == std::string::npos ){
		 errorUndefFunc(yylineno, con->getName());
	 }
 }
