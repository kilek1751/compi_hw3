%{
	#include <iostream>
	#include <stdlib.h>
	#include "source.hpp"
	#include "hw3_output.hpp"
	#include "scope.h"

	int yylex();
	extern int yylineno;
	extern void discoveringYYSTYPE(int yy);
	int yyerror(const char * message);
	
%}

%token LEXERROR BOOL
%token VOID INT BYTE B ENUM TRUE FALSE RETURN WHILE IF
%token BREAK CONTINUE SC COMMA LPAREN RPAREN LBRACE RBRACE
%token  ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left RELEQ
%nonassoc RELOP
%left BINOPL
%left BINOPH
%right CAST
%right NOT
%left PARANS
%nonassoc THEN
%nonassoc ELSE


%%

Program	: Enums Funcs 																								{};
Funcs : /*epsilon*/ 																									{};
Funcs : FuncDecl Funcs 																								{};
FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE 	{};
Enums : /*epsilon*/																										{};
Enums : EnumDecl Enums 																								{};
EnumDecl : ENUM ID LBRACE EnumeratorList RBRACE SC 										{};
RetType : Type																												{};
RetType : VOID 																												{};
Formals : /*epsilon*/ 																								{};
Formals : FormalsList 																								{};
FormalsList : FormalDecl 																							{};
FormalsList : FormalDecl COMMA FormalsList 														{};
FormalDecl : Type ID 																									{};
FormalDecl : EnumType ID 																							{};
EnumeratorList : Enumerator 																					{};
EnumeratorList : EnumeratorList COMMA Enumerator 											{};
Enumerator : ID 																											{};
Statements : Statement 																								{};
Statements : Statements Statement 																		{};
Statement : LBRACE Statements RBRACE 																	{};
Statement : Type ID SC 																								{};
Statement : EnumType ID SC 																						{};
Statement : EnumDecl 																									{};
Statement : Type ID ASSIGN Exp SC	 																{$1->printData();};
Statement : EnumType ID ASSIGN Exp SC																	{};
Statement : ID ASSIGN Exp SC 																					{};
Statement : Call SC 																									{};
Statement : RETURN SC																									{};
Statement : RETURN Exp SC																							{};
Statement : IF LPAREN Exp RPAREN Statement %prec THEN									{};
Statement : IF LPAREN Exp RPAREN Statement ELSE Statement							{};
Statement : WHILE LPAREN Exp RPAREN Statement 												{};
Statement : BREAK SC 																									{};
Statement : CONTINUE SC 																							{};
Call : ID LPAREN ExpList RPAREN																				{};
Call : ID LPAREN RPAREN																								{};
ExpList : Exp																													{};
ExpList : Exp COMMA ExpList																						{};
Type : INT																														{$$=new TypeContainer(*$1);};
Type : BYTE																														{$$=new TypeContainer(*$1);};
Type : BOOL																												{$$=new TypeContainer(*$1);};
EnumType : ENUM ID																										{};
Exp : LPAREN Exp RPAREN																								{};
Exp : Exp BINOPH Exp 																									{};
Exp : Exp BINOPL Exp																									{};
Exp : ID																															{};
Exp : Call																														{};
Exp : NUM																															{$$=new TypeContainer(INT);};
Exp : NUM B																														{$$=new TypeContainer(B);};
Exp : STRING																													{};
Exp : TRUE																														{$$=new TypeContainer(*$1);};
Exp : FALSE																														{$$=new TypeContainer(*$1);};
Exp : NOT Exp																													{$$=new TypeContainer(BOOL);};
Exp : Exp AND Exp																											{$$=new TypeContainer(BOOL);};
Exp : Exp OR Exp 																											{$$=new TypeContainer(BOOL);};
Exp : Exp RELOP Exp																										{$$=new TypeContainer(BOOL);};
Exp : Exp RELEQ Exp																										{$$=new TypeContainer(BOOL);};
Exp : LPAREN Type RPAREN Exp %prec CAST																{};

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}
