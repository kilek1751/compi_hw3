%{
	#include <iostream>
	#include <stdlib.h>
	#include "source.hpp"
	#include "hw3_output.hpp"
	#include "scope.h"

	int yylex();
	extern int yylineno;
	extern char* yytext;
	extern void discoveringYYSTYPE(int yy);
	TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs);
	int yyerror(const char * message);
	
%}

%token LEXERROR BOOL
%token VOID INT BYTE B ENUM TRUE FALSE RETURN WHILE IF
%token BREAK CONTINUE SC COMMA LPAREN RPAREN LBRACE RBRACE
%token  ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left RELEQ
%nonassoc RELOP
%left BINOPL
%left BINOPH
%right CAST
%right NOT
%left PARANS
%nonassoc THEN
%nonassoc ELSE


%%

Program	: {
	Scope table;
	table.insertScope();
	table.addScopeData(ScopeData("print",0,"blabla"));
}
	Enums Funcs 																								{};
Funcs : /*epsilon*/ 																									{};
Funcs : FuncDecl Funcs 																								{};
FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE 	{};
Enums : /*epsilon*/																										{};
Enums : EnumDecl Enums 																								{};
EnumDecl : ENUM ID LBRACE EnumeratorList RBRACE SC 										{};
RetType : Type																												{};
RetType : VOID 																												{};
Formals : /*epsilon*/ 																								{};
Formals : FormalsList 																								{};
FormalsList : FormalDecl 																							{};
FormalsList : FormalDecl COMMA FormalsList 														{};
FormalDecl : Type ID 																									{};
FormalDecl : EnumType ID 																							{};
EnumeratorList : Enumerator 																					{};
EnumeratorList : EnumeratorList COMMA Enumerator 											{};
Enumerator : ID 																											{};
Statements : Statement 																								{};
Statements : Statements Statement 																		{};
Statement : LBRACE Statements RBRACE 																	{};
Statement : Type ID SC 																								{};
Statement : EnumType ID SC 																						{};
Statement : EnumDecl 																									{};
Statement : Type ID ASSIGN Exp SC	 																{};
Statement : EnumType ID ASSIGN Exp SC																	{};
Statement : ID ASSIGN Exp SC 																					{};
Statement : Call SC 																									{};
Statement : RETURN SC																									{};
Statement : RETURN Exp SC																							{};
Statement : IF LPAREN Exp RPAREN Statement %prec THEN									{};
Statement : IF LPAREN Exp RPAREN Statement ELSE Statement							{};
Statement : WHILE LPAREN Exp RPAREN Statement 												{};
Statement : BREAK SC 																									{};
Statement : CONTINUE SC 																							{};
Call : ID LPAREN ExpList RPAREN																		{};
Call : ID LPAREN RPAREN																								{};
ExpList : Exp																					{$$=new ExpList($1->getType());};
ExpList : Exp COMMA ExpList	{$$=new ExpList($1->getType());$$->addTypes($3->getTypes());};
Type : INT																														{$$=$1;};
Type : BYTE																														{$$=$1;};
Type : BOOL																												{$$=$1;};
EnumType : ENUM ID																										{$$=new Enum($2->getName(),ENUM);};
Exp : LPAREN Exp RPAREN																							{$$=$2;};
Exp : Exp BINOPH Exp 											{ $$ = binOpType($1,$3); };
Exp : Exp BINOPL Exp 											{ $$ = binOpType($1,$3); };
Exp : ID																															{$$=new Id(yytext,ID);};
Exp : Call																														{$$=$1;};
Exp : NUM																															{$$=new Int(yytext,INT);};
Exp : NUM B																														{$$=new Byte($1->getVal(),BYTE);};
Exp : STRING																													{$$=new String(yytext,STRING);$$->printContent();};
Exp : TRUE																														{$$=new Bool(true,TRUE);};
Exp : FALSE																														{$$=new Bool(false,FALSE);};
Exp : NOT Exp																													{$$=new Bool(yytext,BOOL);};
Exp : Exp AND Exp																											{$$=new Bool(yytext,BOOL);};
Exp : Exp OR Exp 																											{$$=new Bool(yytext,BOOL);};
Exp : Exp RELOP Exp																									{$$=new Bool(yytext,BOOL);};
Exp : Exp RELEQ Exp																										{$$=new Bool(yytext,BOOL);};
Exp : LPAREN Type RPAREN Exp %prec CAST																{$$=$2;};

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}


TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs) {
  int type_one = lhs->getType();
  int type_two = rhs->getType();
  int max_type = type_one > type_two ? type_two : type_one;
  return new Int(lhs->getVal() + rhs->getVal(), max_type);
}