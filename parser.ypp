%{
	#include <iostream>
	#include <stdlib.h>
	#include "source.hpp"
	#include "hw3_output.hpp"
	#include "scope.h"

	using namespace output;

	int yylex();
	extern int yylineno;
	extern char* yytext;
	extern void discoveringYYSTYPE(int yy);
	TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs);
	void typeCheck(TypeContainer* lhs,TypeContainer* rhs);
	void isBool(TypeContainer* con);
	void wasDefined(TypeContainer* con);
	void notDefined(TypeContainer* con);
	void CheckDefinedFunc(TypeContainer* con);
	void insertToSymbolTable(TypeContainer* type,TypeContainer* id);
	int yyerror(const char * message);
	Scope table;

%}

%token LEXERROR BOOL
%token VOID INT BYTE B ENUM TRUE FALSE RETURN WHILE IF
%token BREAK CONTINUE SC COMMA LPAREN RPAREN LBRACE RBRACE
%token  ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left RELEQ
%nonassoc RELOP
%left BINOPL
%left BINOPH
%right CAST
%right NOT
%left PARANS
%nonassoc THEN
%nonassoc ELSE


%%

Program	: {
	table.insertScope();
	vector<string> print_func_args;
	vector<string> printi_func_args;
	print_func_args.push_back("STRING");
	printi_func_args.push_back("INT");
	string print_func_type = makeFunctionType("void",print_func_args);
	string printi_func_type = makeFunctionType("void",printi_func_args);
	table.addScopeData(ScopeData("print",0,print_func_type));
	table.addScopeData(ScopeData("printi",0,printi_func_type));
	endScope();
	table.printLastScopeData();
}
	Enums Funcs 																								{};
Funcs : /*epsilon*/ 																									{};
Funcs : FuncDecl Funcs 																								{};
FuncDecl : RetType ID {wasDefined($2)} LPAREN Formals RPAREN LBRACE {/*startscope*/} Statements RBRACE {/*endscope*/} { 
 	vector<string> formals_types = $5->getTypes();	
	string func_type = makeFunctionType($1->getType(),formals_types);
	table.addScopeData(ScopeData($2->getName(),0,func_type));
	endScope();
	table.printLastScopeData();
};
Enums : /*epsilon*/																		{};
Enums : EnumDecl Enums																{};
EnumDecl : ENUM ID {
	wasDefined($2);
} LBRACE EnumeratorList RBRACE SC		{};
RetType : Type																				{$$=$1;};
RetType : VOID																				{$$=$1;};
Formals : /*epsilon*/																	{$$ = new FormalListClass();};
Formals : FormalsList																	{$$=$1;};
FormalsList : FormalDecl															{$$=$1;};
FormalsList : FormalDecl COMMA FormalsList						{((FormalListClass*)$1)->addIds(((FormalListClass*)$3)->getIds());$$=$1;};
FormalDecl : Type ID																	{$$=new FormalListClass(Id($2->getName(),$1->getType()));};
FormalDecl : EnumType ID															{$$=new FormalListClass(Id($2->getName(),$1->getType()));};
EnumeratorList : Enumerator														{$$=new FormalListClass(*$1);};
EnumeratorList : EnumeratorList COMMA Enumerator			{$3->addIds($1->getIds());$$=$3;};
Enumerator : ID	{
	wasDefined($1);
	$$=$1;
};
Statements : Statement																{};
Statements : Statements Statement											{};
Statement : LBRACE Statements RBRACE									{};
Statement : Type ID {wasDefined($2);} SC {

};
Statement : EnumType ID {
	wasDefined($2);
} SC														{};
Statement : EnumDecl															{};
Statement : Type ID {
	wasDefined($2);
	insertToSymbolTable($1,$2);
	} ASSIGN Exp SC	{
	typeCheck($1,$5);
	};
Statement : EnumType ID {wasDefined($2);} ASSIGN Exp SC {

};
Statement : ID { notDefined($1);} ASSIGN Exp SC {typeCheck($1,$4);};
Statement : Call SC																		{};
Statement : RETURN SC																	{};
Statement : RETURN Exp SC															{};
Statement : IF LPAREN CheckType RPAREN Statement %prec THEN	{};
Statement : IF LPAREN CheckType RPAREN Statement ELSE Statement {};
Statement : WHILE LPAREN CheckType RPAREN Statement {};
CheckType : Exp {isBool($1);};
Statement : BREAK SC																	{};
Statement : CONTINUE SC																{};
Call : CheckFunc LPAREN ExpList RPAREN {
	/*
	string& func = $1->getType();
	int pos = func.find_first_of("->");
	string prototypes = func.substr(0,pos);
	string temp = makeFunctionType("void", $4->getTypes());
	pos = temp.find_first_of("->");
	string prototypes_two = temp.substr(0,pos);
	if(prototypes != prototypes_two){
		errorPrototypeMismatch(yylineno, $1->getName(), $1->getTypes());				
	} */
};
Call : CheckFunc LPAREN RPAREN {
	/*
	if($1->getTypes().size() != 0){
		errorPrototypeMismatch(yylineno, $1->getName(), $1->getTypes());
		} */
};
CheckFunc : ID {CheckDefinedFunc($1);};
ExpList : Exp																					{$$=new ExpList($1->getType());};
ExpList : Exp COMMA ExpList														{$$=new ExpList($1->getType());$$->addTypes($3->getTypes());};
Type : INT																						{$$=$1;};
Type : BYTE																						{$$=$1;};
Type : BOOL																						{$$=$1;};
EnumType : ENUM ID																		{$$=new Enum($2->getName(),"ENUM");};
Exp : LPAREN Exp RPAREN																{$$=$2;};
Exp : Exp BINOPH Exp {
	typeCheck($1,$3);
	$$ = binOpType($1,$3);
};
Exp : Exp BINOPL Exp {
	typeCheck($1,$3);
	$$ = binOpType($1,$3);
};
Exp : ID																							{$$=new Id(yytext,"ID");};
Exp : Call																						{$$=$1;};
Exp : NUM																							{$$=new Int(yytext,"INT");};
Exp : NUM B																						{$$=new Byte($1->getVal(),"BYTE");};
Exp : STRING																					{$$=new String(yytext,"STRING");};
Exp : TRUE																						{$$=new Bool(true,"BOOL");};
Exp : FALSE																						{$$=new Bool(false,"BOOL");};
Exp : NOT Exp																					{$$=new Bool(yytext,"BOOL");}; /* should be yytext -> $2->type*/
Exp : Exp AND Exp {
	isBool($1);
	isBool($2);
	$$=new Bool(yytext,"BOOL");};
Exp : Exp OR Exp {
	isBool($1);
	isBool($2);
	$$=new Bool(yytext,"BOOL");
};
Exp : Exp RELOP Exp {
	typeCheck($1,$3);
	$$=new Bool(yytext,"BOOL");
};
Exp : Exp RELEQ Exp {
	typeCheck($1,$3);
	$$=new Bool(yytext,"BOOL");
};
Exp : LPAREN Type RPAREN Exp %prec CAST								{$$=$2;};

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}


TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs) {
  string type_one = lhs->getType();
  string type_two = rhs->getType();
  if (type_one == "INT" || type_two == "INT"){
	  return new Int(lhs->getVal()+rhs->getVal(),"INT");
  }
  return new Int(lhs->getVal() + rhs->getVal(), "BYTE");
}

void typeCheck(TypeContainer* lhs,TypeContainer* rhs){
	 if(lhs->getType() != rhs->getType()){
		errorMismatch(yylineno);
		exit(0);
	}
}

void isBool(TypeContainer* con){
		if (con->getType() == "BOOL"){
			errorMismatch(yylineno);
			exit(0);
		}
 }

void wasDefined(TypeContainer* con){
	if( table.exist( con->getName() )){
		errorDef(yylineno, con->getName());
		exit(0);
	}
}

void notDefined(TypeContainer* con){
	 if(!table.exist( con->getName() )){
		errorUndef(yylineno, con->getName());
		exit(0);
	}
}

void CheckDefinedFunc(TypeContainer* con){
	 string arrow = "->";
	 if( !table.exist( con->getName()) ||
	 			con->getType().find(arrow) == std::string::npos ){
		 errorUndefFunc(yylineno, con->getName());
		 exit(0);
	 }
}

void insertToSymbolTable(TypeContainer* type,TypeContainer* id){
	return;
	// ScopeData inserted_element = ScopeData(id->getName(),table.nextOffset(),type->getType());
	// table.addScopeData(inserted_element);
}
