%{
	#include <iostream>
	#include <stdlib.h>
	#include "source.hpp"
	#include "hw3_output.hpp"
	#include "scope.h"

	using namespace output;

	int yylex();
	extern int yylineno;
	extern char* yytext;
	extern void discoveringYYSTYPE(int yy);
	TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs);
	void typeCheck(TypeContainer* lhs,TypeContainer* rhs);
	int yyerror(const char * message);
	Scope table;
	
%}

%token LEXERROR BOOL
%token VOID INT BYTE B ENUM TRUE FALSE RETURN WHILE IF
%token BREAK CONTINUE SC COMMA LPAREN RPAREN LBRACE RBRACE
%token  ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left RELEQ
%nonassoc RELOP
%left BINOPL
%left BINOPH
%right CAST
%right NOT
%left PARANS
%nonassoc THEN
%nonassoc ELSE


%%

Program	: {
	table.insertScope();
	vector<string> print_func_args;
	vector<string> printi_func_args;
	print_func_args.push_back("string");
	printi_func_args.push_back("int");
	string print_func_type = makeFunctionType("void",print_func_args);
	string printi_func_type = makeFunctionType("void",printi_func_args);
	table.addScopeData(ScopeData("print",0,print_func_type));
	table.addScopeData(ScopeData("printi",0,printi_func_type));
	endScope();
	table.printLastScopeData();
}
	Enums Funcs 																								{};
Funcs : /*epsilon*/ 																									{};
Funcs : FuncDecl Funcs 																								{};
FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE { 
 	vector<string> formals_types = $4->getTypes();	
	string func_type = makeFunctionType($1->getType(),formals_types);
	table.addScopeData(ScopeData($2->getName(),0,func_type));
	endScope();
	table.printLastScopeData();
};
Enums : /*epsilon*/																										{};
Enums : EnumDecl Enums 																								{};
EnumDecl : ENUM ID LBRACE EnumeratorList RBRACE SC 										{};
RetType : Type								{$$=$1;};
RetType : VOID 								{$$=$1;};
Formals : /*epsilon*/ 						{$$ = new FormalListClass();};
Formals : FormalsList 						{$$=$1;};
FormalsList : FormalDecl 					{$$=$1;};
FormalsList : FormalDecl COMMA FormalsList 	{((FormalListClass*)$1)->addIds(((FormalListClass*)$3)->getIds());$$=$1;};
FormalDecl : Type ID 						{$$=new FormalListClass(Id($2->getName(),$1->getType()));};
FormalDecl : EnumType ID 					{$$=new FormalListClass(Id($2->getName(),$1->getType()));};
EnumeratorList : Enumerator 																					{};
EnumeratorList : EnumeratorList COMMA Enumerator 											{};
Enumerator : ID 																											{};
Statements : Statement 																								{};
Statements : Statements Statement 																		{};
Statement : LBRACE Statements RBRACE 																	{};
Statement : Type ID SC 																								{};
Statement : EnumType ID SC 																						{};
Statement : EnumDecl 																									{};
Statement : Type ID {} ASSIGN Exp SC	{
	typeCheck($1,$5);
	};
Statement : EnumType ID ASSIGN Exp SC																	{};
Statement : ID {} ASSIGN Exp SC 	{
	typeCheck($1->getType(),$4->getType());
	};
Statement : Call SC 																									{};
Statement : RETURN SC																									{};
Statement : RETURN Exp SC																							{};
Statement : IF LPAREN Exp RPAREN Statement %prec THEN									{};
Statement : IF LPAREN Exp RPAREN Statement ELSE Statement							{};
Statement : WHILE LPAREN Exp RPAREN Statement 												{};
Statement : BREAK SC 																									{};
Statement : CONTINUE SC 																							{};
Call : ID LPAREN ExpList RPAREN																		{};
Call : ID LPAREN RPAREN																								{};
ExpList : Exp																					{$$=new ExpList($1->getType());};
ExpList : Exp COMMA ExpList	{$$=new ExpList($1->getType());$$->addTypes($3->getTypes());};
Type : INT																														{$$=$1;};
Type : BYTE																														{$$=$1;};
Type : BOOL																												{$$=$1;};
EnumType : ENUM ID																										{$$=new Enum($2->getName(),"ENUM");};
Exp : LPAREN Exp RPAREN																							{$$=$2;};
Exp : Exp BINOPH Exp 											{ $$ = binOpType($1,$3); };
Exp : Exp BINOPL Exp 											{ $$ = binOpType($1,$3); };
Exp : ID																															{$$=new Id(yytext,"ID");};
Exp : Call																														{$$=$1;};
Exp : NUM																															{$$=new Int(yytext,"INT");};
Exp : NUM B																														{$$=new Byte($1->getVal(),"BYTE");};
Exp : STRING																													{$$=new String(yytext,"STRING");};
Exp : TRUE																														{$$=new Bool(true,"TRUE");};
Exp : FALSE																														{$$=new Bool(false,"FALSE");};
Exp : NOT Exp																													{$$=new Bool(yytext,"BOOL");};
Exp : Exp AND Exp																											{$$=new Bool(yytext,"BOOL");};
Exp : Exp OR Exp 																											{$$=new Bool(yytext,"BOOL");};
Exp : Exp RELOP Exp																									{$$=new Bool(yytext,"BOOL");};
Exp : Exp RELEQ Exp																										{$$=new Bool(yytext,"BOOL");};
Exp : LPAREN Type RPAREN Exp %prec CAST																{$$=$2;};

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}


TypeContainer* binOpType(TypeContainer* lhs, TypeContainer* rhs) {
  string type_one = lhs->getType();
  string type_two = rhs->getType();
  if (type_one == "INT" || type_two == "INT"){
	  return new Int(lhs->getVal()+rhs->getVal(),"INT");
  }
  if (type_one == "BYTE" || type_two == "BYTE"){
	  return new Int(lhs->getVal()+rhs->getVal(),"BYTE");
  }
  return new Int(lhs->getVal() + rhs->getVal(), "B");
}

 void typeCheck(TypeContainer* lhs,TypeContainer* rhs){
	 if(lhs->getType()!=rhs->getType()){
		 errorMismatch(yylineno);
	 }
 }